# Flujo Seguro, Flujo Inseguro y Explotación de Lógica de Negocio

Profundización completa con ejemplos y modelos de mitigación para entornos modernos

---

## Introducción

Las vulnerabilidades más rentables hoy no dependen de inyecciones o sobreescritura de memoria, sino de fallos en el flujo de negocio. Cuando una aplicación permite que el cliente manipule pasos, estados o valores críticos, aparece un vector que ni WAFs ni firmas pueden detectar. Esta guía describe los patrones centrales: flujo seguro e inseguro, manipulación de envíos, omisión de restricciones, estados corruptos, reparación de integridad, explotación de límites, abuso de la pausa y el rol de Burp Suite en pruebas autorizadas.

---

## 1. Flujo seguro vs flujo inseguro

El flujo representa la secuencia de pasos que la aplicación exige para que un proceso sea válido.

### Flujo seguro

El servidor controla las transiciones. Ningún paso depende de datos provenientes del cliente y cada transición está condicionada por reglas verificadas en backend.

**Características:**

* Los estados permitidos y prohibidos están definidos como una máquina de estados.
* El servidor recalcula siempre datos críticos (precio, stock, elegibilidad).
* Las operaciones importantes exigen tokens de idempotencia.
* El sistema rechaza transiciones que no cumplen precondiciones.

**Ejemplo:**
Un pedido sólo puede pasar a “Reembolso permitido” si el servidor valida:

* pedido entregado,
* ventana de reembolso abierta,
* usuario autorizado.

Si cualquier condición falla, la transición es rechazada.

### Flujo inseguro

La aplicación delega al cliente pasos que deben validarse en servidor. El cliente puede omitir pasos, alterar valores o reordenar solicitudes.

**Características:**

* El servidor acepta campos enviados por el cliente sin verificarlos.
* No se valida que el estado actual permita la transición.
* No se registra idempotencia.
* No existe bloqueo de concurrencia.

**Ejemplo:**
Un cliente envía directamente:

```
POST /refund {
  "order_id": 5521,
  "status": "refund_requested"
}
```

El backend acepta y cambia el estado sin verificar si el pedido fue entregado.

---

## 2. Mitigación del flujo

La defensa requiere mecanismos que obliguen a que cada estado sea coherente con el negocio.

**Elementos clave:**

1. **Fuente de verdad en servidor:** ninguna regla de precios, descuentos o límites debe ser suministrada por el cliente.
2. **Máquina de estados:** cada endpoint verifica el estado actual y las precondiciones.
3. **Idempotencia:** prevenir reenvíos múltiples del mismo evento.
4. **Transacciones atómicas:** checkout, reembolsos, uso de cupones y deducciones de stock.
5. **Bloqueos de concurrencia:** evitar doble gasto o dobles reservas.
6. **Auditoría automatizada:** detectar intentos fuera de secuencia.

**Ejemplo corregido:**
El endpoint `/refund` valida:

* `order.status == delivered`
* `refund_pending == false`
* `idempotency_token` único

Si la transición no es legítima, se rechaza.

---

## 3. Manipulación de envíos

Consiste en alterar las solicitudes que la aplicación envía al backend: precios, cantidades, cupones, límites, banderas booleanas, estados.

**Ejemplo inseguro:**
Cliente envía:

```
POST /checkout
{
  "product_id": 40,
  "price": 1,
  "qty": 1
}
```

El backend acepta y cobra 1 unidad.

**Mitigación:**
El backend ignora cualquier valor administrativo proveniente del cliente:

```
product = db.get_product(product_id);
total = product.price * qty;
```

Si `client_price != server_price`, registrar intento anómalo.

---

## 4. Omisión de restricción y flujo de estado

La omisión ocurre cuando el cliente salta pasos del flujo. Si el backend no valida estados, puede generarse corrupción del negocio.

**Ejemplo inseguro:**
Checkout requiere:

1. Confirmar dirección
2. Seleccionar método de pago
3. Revisar pedido
4. Pagar

El cliente envía directamente:

```
POST /payment/execute
```

sin haber completado las etapas anteriores.

**Mitigación:**
Máquina de estados estricta:

* `/payment/execute` sólo se ejecuta si el estado es `ready_for_payment`.
* La API rechaza cualquier acceso que no cumpla precondiciones.

---

## 5. Reparación de integridad insegura (arreglar sistemas que confiaban en el cliente)

### 1. Auditoría

Identificar todos los campos que provienen del cliente y afectan el cálculo o los estados.

### 2. Migración

Mover el cálculo completo al servidor: precios, impuestos, descuentos, disponibilidad.

### 3. Remediación histórica

Revisar logs y transacciones que utilizaron parámetros manipulables. Implementar procesos compensatorios cuando sea necesario.

### 4. Protección mediante firma

Si un campo debe permanecer por compatibilidad, usar firmas HMAC con claves del servidor para detectar manipulación.

### 5. Fallos cerrados

En caso de discrepancia, el sistema rechaza la operación sin intentar “arreglarla”.

**Ejemplo:**
Un cupón enviado como texto plano desde el cliente antes se validaba sólo comparando el string. Ahora se convierte en un token firmado:

```
coupon_token = HMAC(server_secret, coupon_id + expiration)
```

---

## 6. Explotación de límites (rate limits)

Los límites mal diseñados permiten bypass o abuso.

### Ejemplo inseguro

El sistema permite 5 intentos por minuto por IP. Atacante usa 200 proxies → 1000 intentos simultáneos.

### Explotación avanzada

Si un endpoint de cupón verifica primero “estado disponible” y después “marcar como usado”, un atacante realiza 20 solicitudes simultáneas.
Todas leen “disponible” antes de que el backend actualice el estado. Varias solicitudes pasan.

### Mitigación

* Límites por entidad fuerte: usuario, tarjeta, fingerprint.
* Bloqueos transaccionales:

```
UPDATE coupons SET used = true WHERE id = ? AND used = false;
```

Si filas afectadas = 0 → cupón ya usado.

---

## 7. Explotación mediante pausa y condiciones de carrera

La pausa consiste en retener solicitudes para causar concurrencia artificial. Permite que múltiples solicitudes lean el mismo estado antes de que se actualice.

**Ejemplo inseguro:**
Stock = 1.
Dos solicitudes a `/reserve` se envían mientras se congelan las respuestas.
Ambas leen stock = 1.
Ambas confirman.

**Mitigación:**
El stock se modifica con transacciones atómicas:

```
UPDATE items
SET stock = stock - 1
WHERE id = ? AND stock >= 1
```

Sólo una solicitud puede afectar la fila.

---

## 8. Burp Suite en pruebas autorizadas

Burp permite interceptar, modificar, pausar y repetir solicitudes. Su valor no es el ataque sino revelar dónde la aplicación confía demasiado en el cliente.

### Qué revela Burp en flujos inseguros

* Endpoints que aceptan parámetros críticos desde el cliente.
* Estados que se pueden manipular manualmente.
* Falta de idempotencia.
* Posibilidad de replays.
* Race conditions por falta de bloqueo.

### Qué buscar como defensor

* Requests repetidas con pequeñas variaciones.
* Replays exactos con timestamps casi idénticos.
* Secuencias fuera de orden lógico.
* Cambios de valores sensibles.

---

## 9. Ejemplos integrados

### Ejemplo 1 — Precio manipulado

**Inseguro:**
El sistema confía en el valor `client_price`.
**Ataque:** cambiar `price=100` → `1`.
**Mitigación:** ignorar `client_price` y recalcular.

---

### Ejemplo 2 — Cupón usado más de una vez

**Inseguro:**
El backend marca un cupón como usado sólo al final del checkout.
**Ataque:** dos solicitudes simultáneas usan el cupón antes de que se marque.
**Mitigación:** marcar cupón como “in use” en DB de forma atómica.

---

### Ejemplo 3 — Reembolso fuera de secuencia

**Inseguro:**
El endpoint `/refund` no verifica el estado del pedido.
**Ataque:** solicitar reembolso sin entrega.
**Mitigación:** verificar estado + token de idempotencia.

---

### Ejemplo 4 — Salto de pasos en el checkout

**Inseguro:**
La API no valida que se hayan completado todos los pasos previos.
**Ataque:** ejecución directa del endpoint de pago.
**Mitigación:** imponer máquina de estados.

---

## Conclusión

Los ataques modernos se producen cuando el sistema asume que el cliente se comporta honestamente. El objetivo central es eliminar esa confianza: todas las reglas críticas deben evaluarse en el backend, las transiciones deben estar controladas por una máquina de estados y los recursos consumibles deben gestionarse de forma transaccional. Cuando la aplicación deja de confiar en el cliente, la superficie de ataque de la lógica de negocio se reduce drásticamente.
